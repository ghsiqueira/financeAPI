const express = require('express');
const { body, validationResult } = require('express-validator');
const Category = require('../models/Category');
const Transaction = require('../models/Transaction');
const Budget = require('../models/Budget');
const auth = require('../middleware/auth');

const router = express.Router();

// Criar categoria personalizada
router.post('/', auth, [
  body('name').notEmpty().withMessage('Nome √© obrigat√≥rio'),
  body('type').isIn(['income', 'expense']).withMessage('Tipo deve ser income ou expense'),
  body('icon').optional().isString(),
  body('color').optional().matches(/^#[0-9A-F]{6}$/i).withMessage('Cor deve ser um c√≥digo hexadecimal v√°lido')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Dados inv√°lidos',
        errors: errors.array()
      });
    }

    const { name, type, icon = 'üí∞', color = '#4CAF50' } = req.body;

    // Verificar se j√° existe uma categoria com o mesmo nome para este usu√°rio
    const existingCategory = await Category.findOne({
      userId: req.user._id,
      name: { $regex: new RegExp(`^${name}$`, 'i') },
      type
    });

    if (existingCategory) {
      return res.status(400).json({
        success: false,
        message: 'J√° existe uma categoria com este nome'
      });
    }

    const category = new Category({
      name,
      type,
      icon,
      color,
      userId: req.user._id,
      isDefault: false
    });

    await category.save();

    res.status(201).json({
      success: true,
      message: 'Categoria criada com sucesso',
      category
    });
  } catch (error) {
    console.error('Erro ao criar categoria:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Listar categorias (padr√µes + personalizadas do usu√°rio)
router.get('/', auth, async (req, res) => {
  try {
    const { type } = req.query;
    
    const filters = {
      $or: [
        { userId: req.user._id }, // Categorias personalizadas do usu√°rio
        { userId: null, isDefault: true } // Categorias padr√£o do sistema
      ]
    };
    
    if (type) {
      filters.type = type;
    }

    const categories = await Category.find(filters)
      .sort({ isDefault: -1, name: 1 });

    // Remover duplicatas e validar √≠cones
    const uniqueCategories = [];
    const seenNames = new Set();

    for (const category of categories) {
      const categoryName = category.name.toLowerCase().trim();
      
      // Validar se tem √≠cone v√°lido (n√£o vazio e n√£o √© '?')
      const hasValidIcon = category.icon && 
                          category.icon.trim() !== '' && 
                          category.icon !== '?';
      
      const hasValidColor = category.color && category.color.trim() !== '';
      
      // S√≥ adiciona se n√£o for duplicada e tiver dados v√°lidos
      if (!seenNames.has(categoryName) && hasValidIcon && hasValidColor) {
        seenNames.add(categoryName);
        
        // Contar uso de cada categoria
        const transactionCount = await Transaction.countDocuments({
          category: category._id,
          userId: req.user._id
        });

        const budgetCount = await Budget.countDocuments({
          category: category._id,
          userId: req.user._id
        });

        uniqueCategories.push({
          ...category.toObject(),
          usage: {
            transactions: transactionCount,
            budgets: budgetCount,
            total: transactionCount + budgetCount
          }
        });
      }
    }

    res.json({
      success: true,
      categories: uniqueCategories,
      data: uniqueCategories
    });
  } catch (error) {
    console.error('Erro ao listar categorias:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Obter categoria por ID
router.get('/:id', auth, async (req, res) => {
  try {
    const category = await Category.findOne({
      _id: req.params.id,
      $or: [
        { userId: req.user._id },
        { userId: null, isDefault: true }
      ]
    });

    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Categoria n√£o encontrada'
      });
    }

    // Obter estat√≠sticas de uso
    const transactionCount = await Transaction.countDocuments({
      category: category._id,
      userId: req.user._id
    });

    const budgetCount = await Budget.countDocuments({
      category: category._id,
      userId: req.user._id
    });

    // Obter total gasto/recebido nesta categoria nos √∫ltimos 6 meses
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    const totalAmount = await Transaction.aggregate([
      {
        $match: {
          category: category._id,
          userId: req.user._id,
          date: { $gte: sixMonthsAgo }
        }
      },
      {
        $group: {
          _id: null,
          total: { $sum: '$amount' },
          count: { $sum: 1 }
        }
      }
    ]);

    const stats = {
      transactions: transactionCount,
      budgets: budgetCount,
      lastSixMonths: {
        total: totalAmount.length > 0 ? totalAmount[0].total : 0,
        count: totalAmount.length > 0 ? totalAmount[0].count : 0
      }
    };

    res.json({
      success: true,
      category: {
        ...category.toObject(),
        stats
      }
    });
  } catch (error) {
    console.error('Erro ao obter categoria:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Atualizar categoria (apenas categorias personalizadas)
router.put('/:id', auth, [
  body('name').optional().notEmpty().withMessage('Nome n√£o pode estar vazio'),
  body('icon').optional().isString(),
  body('color').optional().matches(/^#[0-9A-F]{6}$/i).withMessage('Cor deve ser um c√≥digo hexadecimal v√°lido')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Dados inv√°lidos',
        errors: errors.array()
      });
    }

    const category = await Category.findOne({
      _id: req.params.id,
      userId: req.user._id,
      isDefault: false
    });

    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Categoria n√£o encontrada ou n√£o pode ser editada'
      });
    }

    // Se estiver alterando o nome, verificar duplicatas
    if (req.body.name && req.body.name !== category.name) {
      const existingCategory = await Category.findOne({
        _id: { $ne: req.params.id },
        userId: req.user._id,
        name: { $regex: new RegExp(`^${req.body.name}$`, 'i') },
        type: category.type
      });

      if (existingCategory) {
        return res.status(400).json({
          success: false,
          message: 'J√° existe uma categoria com este nome'
        });
      }
    }

    const updatedCategory = await Category.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );

    res.json({
      success: true,
      message: 'Categoria atualizada com sucesso',
      category: updatedCategory
    });
  } catch (error) {
    console.error('Erro ao atualizar categoria:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Deletar categoria (apenas categorias personalizadas)
router.delete('/:id', auth, async (req, res) => {
  try {
    const category = await Category.findOne({
      _id: req.params.id,
      userId: req.user._id,
      isDefault: false
    });

    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Categoria n√£o encontrada ou n√£o pode ser deletada'
      });
    }

    // Verificar se a categoria est√° sendo usada
    const transactionCount = await Transaction.countDocuments({
      category: req.params.id,
      userId: req.user._id
    });

    const budgetCount = await Budget.countDocuments({
      category: req.params.id,
      userId: req.user._id
    });

    if (transactionCount > 0 || budgetCount > 0) {
      return res.status(400).json({
        success: false,
        message: `N√£o √© poss√≠vel deletar a categoria. Ela est√° sendo usada em ${transactionCount} transa√ß√£o(√µes) e ${budgetCount} or√ßamento(s).`,
        usage: {
          transactions: transactionCount,
          budgets: budgetCount
        }
      });
    }

    await Category.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: 'Categoria deletada com sucesso'
    });
  } catch (error) {
    console.error('Erro ao deletar categoria:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Obter estat√≠sticas por categoria
router.get('/stats/spending', auth, async (req, res) => {
  try {
    const { startDate, endDate, type = 'expense' } = req.query;
    
    const dateFilter = {};
    if (startDate && endDate) {
      dateFilter.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    } else {
      // √öltimos 30 dias por padr√£o
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      dateFilter.date = { $gte: thirtyDaysAgo };
    }

    const stats = await Transaction.aggregate([
      {
        $match: {
          userId: req.user._id,
          type: type,
          ...dateFilter
        }
      },
      {
        $group: {
          _id: '$category',
          total: { $sum: '$amount' },
          count: { $sum: 1 },
          avg: { $avg: '$amount' }
        }
      },
      {
        $lookup: {
          from: 'categories',
          localField: '_id',
          foreignField: '_id',
          as: 'category'
        }
      },
      {
        $unwind: '$category'
      },
      {
        $sort: { total: -1 }
      }
    ]);

    // Calcular total geral
    const grandTotal = stats.reduce((sum, item) => sum + item.total, 0);

    // Adicionar percentuais
    const statsWithPercentage = stats.map(item => ({
      ...item,
      percentage: grandTotal > 0 ? (item.total / grandTotal) * 100 : 0
    }));

    res.json({
      success: true,
      stats: statsWithPercentage,
      summary: {
        grandTotal,
        categoryCount: stats.length,
        period: { startDate, endDate }
      }
    });
  } catch (error) {
    console.error('Erro ao obter estat√≠sticas por categoria:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Obter √≠cones dispon√≠veis
router.get('/icons/available', (req, res) => {
  const availableIcons = [
    'üí∞', 'üí∏', 'üè†', 'üöó', 'üçΩÔ∏è', 'üõí', '‚ö°', 'üì±', 
    'üè•', 'üíä', 'üé¨', 'üéÆ', 'üìö', '‚úàÔ∏è', 'üèñÔ∏è', 'üëï',
    '‚õΩ', 'üöå', 'üöá', 'üöï', 'üçï', '‚òï', 'üç∫', 'üéØ',
    'üíº', 'üíª', 'üìà', 'üéì', 'üèãÔ∏è', 'üéµ', 'üì∫', 'üé™',
    'üêï', 'üê±', 'üå±', 'üîß', 'üé®', 'üíç', 'üéÅ', 'üì¶'
  ];

  const iconCategories = {
    finance: ['üí∞', 'üí∏', 'üíº', 'üìà', 'üíç'],
    home: ['üè†', '‚ö°', 'üì±', 'üîß', 'üå±'],
    transport: ['üöó', '‚õΩ', 'üöå', 'üöá', 'üöï', '‚úàÔ∏è'],
    food: ['üçΩÔ∏è', 'üõí', 'üçï', '‚òï', 'üç∫'],
    health: ['üè•', 'üíä', 'üèãÔ∏è'],
    entertainment: ['üé¨', 'üéÆ', 'üéØ', 'üéµ', 'üì∫', 'üé™'],
    education: ['üìö', 'üéì'],
    shopping: ['üëï', 'üì¶', 'üéÅ'],
    travel: ['üèñÔ∏è', '‚úàÔ∏è'],
    pets: ['üêï', 'üê±'],
    other: ['üé®', 'üíª']
  };

  res.json({
    success: true,
    icons: {
      all: availableIcons,
      categories: iconCategories
    }
  });
});

// Rota para limpar categorias duplicadas (executar uma vez)
router.post('/cleanup-duplicates', auth, async (req, res) => {
  try {
    console.log('üßπ Iniciando limpeza de categorias duplicadas...');
    
    const categories = await Category.find({ 
      userId: req.user._id 
    });
    
    const uniqueMap = new Map();
    const toDelete = [];

    for (const category of categories) {
      const key = category.name.toLowerCase().trim();
      
      if (!uniqueMap.has(key)) {
        // Primeira ocorr√™ncia - verificar se tem √≠cone v√°lido
        if (category.icon && category.icon !== '?' && category.icon.trim() !== '') {
          uniqueMap.set(key, category._id);
        } else {
          // Se n√£o tem √≠cone v√°lido, tamb√©m marca para deletar
          toDelete.push(category._id);
        }
      } else {
        // Duplicata - marcar para deletar
        toDelete.push(category._id);
      }
    }

    // Deletar duplicatas e categorias sem √≠cone v√°lido
    let deletedCount = 0;
    if (toDelete.length > 0) {
      const result = await Category.deleteMany({ 
        _id: { $in: toDelete } 
      });
      deletedCount = result.deletedCount;
    }

    console.log(`‚úÖ Limpeza conclu√≠da: ${deletedCount} categorias removidas`);

    res.json({
      success: true,
      message: `${deletedCount} categorias duplicadas/inv√°lidas removidas`,
      data: { 
        deleted: deletedCount,
        remaining: uniqueMap.size
      }
    });
  } catch (error) {
    console.error('Erro ao limpar duplicatas:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao limpar duplicatas'
    });
  }
});

// DEBUG: Ver todas as categorias (SEM autentica√ß√£o - apenas para desenvolvimento)
router.get('/debug/all-public', async (req, res) => {
  try {
    const categories = await Category.find({});

    res.json({
      success: true,
      total: categories.length,
      categories: categories.map(cat => ({
        id: cat._id,
        name: cat.name,
        icon: cat.icon,
        iconCode: cat.icon ? cat.icon.charCodeAt(0) : null,
        color: cat.color,
        type: cat.type,
        isDefault: cat.isDefault,
        userId: cat.userId
      }))
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

router.get('/debug/fix-all-icons', async (req, res) => {
  try {
    const iconMap = {
      'alimenta√ß√£o': 'üçΩÔ∏è',
      'transporte': 'üöó',
      'moradia': 'üè†',
      'sa√∫de': 'üè•',
      'educa√ß√£o': 'üìö',
      'lazer': 'üé¨',
      'vestu√°rio': 'üëï',
      'compras': 'üõí',
      'beleza & cuidados': 'üíÑ',
      'academia': 'üèãÔ∏è',
      'combust√≠vel': '‚õΩ',
      'farm√°cia': 'üíä',
      'contas & impostos': 'üìã',
      'viagem': '‚úàÔ∏è',
      'pets': 'üêï',
      'assinaturas': 'üì±',
      'sal√°rio': 'üíº',
      'freelance': 'üíª',
      'investimentos': 'üìà',
      'bonus': 'üéÅ',
      'vendas': 'üíµ',
      'aluguel recebido': 'üèòÔ∏è',
      'restitui√ß√£o': '‚Ü©Ô∏è',
      'outros': 'üí∞',
      'transfer√™ncia': 'üîÑ',
      'categoria teste': 'üß™'
    };

    const categories = await Category.find({});
    let updated = 0;

    for (const category of categories) {
      const nameKey = category.name.toLowerCase().trim();
      
      // Verificar se o √≠cone √© um nome do Ionicons (texto sem emoji)
      const isTextIcon = category.icon && /^[a-z-]+$/i.test(category.icon);
      
      if (!category.icon || category.icon === '?' || category.icon.trim() === '' || isTextIcon) {
        const newIcon = iconMap[nameKey] || (category.type === 'income' ? 'üíµ' : 'üí∞');
        
        await Category.findByIdAndUpdate(category._id, {
          icon: newIcon
        });
        
        updated++;
      }
    }

    res.json({
      success: true,
      message: `${updated} categorias atualizadas com √≠cones emoji`,
      updated,
      details: '√çcones do Ionicons convertidos para emojis'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

module.exports = router;